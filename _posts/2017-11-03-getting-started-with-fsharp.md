---
layout: post
author: Martin Elsman
category : lessons
tags : [Fsharp,functional programming]
---
{% include JB/setup %}

F# is a programming language aimed at executing programs on the .NET
platform. We will explore how to develop F# programs that run under
Mono, an open-source implementation of Microsoft's Common Intermediate
Runtime (CLR). We will see that it is perfectly possible, with certain
restrictions, to develop portable programs and code that runs on a
variety of platforms, including MacOS, Microsoft Windows, Linux, and,
last but not least, a large varity of mobile platforms out there.

We will, essentially, be using a number of open-source tools. The most
essential tool is the _terminal program_, which allows the developer
to navigate around the file system and to execute commands, which
includes compiling and executing programs.

Next, we will assume that the user has installed an editor on the
machine. Whereas, many different editors exist, we will recommend
`gedit`, which is available on all platforms (on MacOS, it may be
installed using [Homebrew](https://brew.sh/); just type `brew install gedit`).

Finally, the user needs to install [Mono](http://www.mono-project.com/), which, under MacOS, also
can be installed using [Homebrew](https://brew.sh/); just type `brew
install mono` in a terminal.

After having installed these tools, we are ready to run the
`fsharpi` program in the terminal. In your terminal window, simply
write

    $ fsharpi

The `fsharpi` program will launch with a greeting and will be ready
to receive commands:

```
F# Interactive for F# 4.1
Freely distributed under the Apache 2.0 Open Source License

For help type #help;;

>
```

## Expressions and Types

The `fsharpi` program accepts commands as input, but it is also
possible to type in an F# expression. Here is an example:

```
> 4+2*8;;
val it : int = 20

>
```

Notice that expressions and commands needs to be terminated with
`;;` to indicate that `fsharpi` can process the input. After
`fsharpi` receives the input, a number of things happen. First, the
input is analysed and it is determined that the input corresponds to
an expression that has type `int`. Then the expression is compiled
into CIL bytecode, and finally, the bytecode is executed and the
result, together with its type `int`, is printed in the feedback
message `val it : int = 20`. Notice here the distinction between
analysing and compiling the expression and the process of executing
the generated bytecode, resulting in a final value; the expression is
evaluated only if the expression can be given a type (in this case
`int`). Finally, notice also that the resulting value is bound to a
so-called variable `it`, which the user can refer to later if the
result is needed for another computation:

```
> (it+3)*2;;
val it : int = 23
```

From the above interaction, we see that F# remembers the value of the
variable `it` when calculating the value of the new expression, but
we also see that the variable `it` is now replaced with a new
binding, which associates the variable `it` with the value
`46`. We shall see later that a programmer can easily bind values to
new variables and that the programmer may choose names for variables
almost arbitrarily. Notice also that the programmer may use
parentheses to circumvent the usual precedence rules of mathematics.

F# has support for a large number of built-in types, including
integers (`int`), double-precision floats (`float`), strings
(`string`), and booleans (`bool`). As we shall see later, it is
also possible for the developer to declare his or her's own types. F#
also has a number of built-in operations on values of the various
types; we have seen how the operation `+` operates on two integers,
resulting in a new integer. The fact that `+` behaves like this can
be specified by saying that `+` has the (function) type `int -> int
-> int`. In short, we shall often use the following syntax to specify
this property:

    val (+) : int -> int -> int

Similarly, other operations on integers are available as well:

    val (-) : int -> int -> int
    val (*) : int -> int -> int
    val (/) : int -> int -> int
    val abs : int -> int
    val max : int -> int -> int
    val min : int -> int -> int

**Exercise 1:** _Play around with various expressions in the
`fsharpi` program and evaluate the result of computing the number of
minutes it takes for a train to run from Copenhagen to Aarhus given
that it runs on average 145km/hour and that the distance between
Copenhagen and Aarhus is 290km._

Of course, it is possible to program with values other than integers,
as indicated by the fact that F# supports other types than
`int`. For instance, F# supports programming with 64-bit
double-precision floating-point values, which have type `float`:

```
> sin(4.9+float(2*8));;
val it : float = 0.8871575287
```

The value resulting from evaluating the expression is determined to
have type `float` and, again, the result of evaluating the
expression is bound to the variable `it`. We also see that it is
possible to use the `float(...)` function to convert an integer
value into a value of type `float`.

**Exercise 2:** _The formula for calculating the body-mass-index for a
person is identical to the weight of the person (in kilos) divided by
the height (in meters) squared. Calculate the body mass index of a
person of height 205cm and weight 89 kilos._

## Variables

As mentioned, it is possible in F# for a programmer to bind a value to
an identifier specified by the programmer. Such a binding is
introduced with a so-called `let` construct:

```
> let myhousenumber = 24;;
val myhousenumber : int = 24
> let nexthousenumber = myhousenumber + 1;;
val nexthousenumber : int = 25
> let pi = 3.14;;
val pi : float = 3.14
> let height = sin pi;;
val height : float = 0.001592652916
```

As we can see, it is straightforward to create new bindings and to use
the values associated to the introduced variables. In the above code,
notice the use of the sine-function:

    val sin : float -> float

Other functions (besides most of those available on integers) are
available on floats as well. Such functions include `cos`, `tan`,
`exp`, and so on.

## Strings

Another essential data type available in F# is the `string` type:

```
> let hello = "Hello";;
val hello : string = "Hello"

> let mystring = hello + " World";;
val mystring : string = "Hello World"
```

Here we see that string constants are sequences of characters and that
string constants are enclosed in double quotes ("). Moreover, the
operator `+` is _overloaded_ to also work for strings:

    val (+) : string -> string -> string

The effect of "adding" to strings, which is also called _catenation_,
is to create a new string that contains the argument strings put together in
sequence. A number of other operations are available on strings, but
to access most of them, it is required to access the, so-called, _module_
containing string operations. Modules are referred to by name and,
essentially (and for now), a module contains a number of variable
bindings. The module containing string-operations is the module
`String` and to access functionality within a module, we use the
so-called _dot-notation_, which allows us, for instance, to get
information about the length of a string:

```
> let mylen = String.length mystring;;
val mylen : int = 11
```

We see that the result of applying the `String.length` function to a
concrete string is an integer, which we can also see by inspecting the
function:

```
> String.length;;
val it : (string -> int) = <fun:it@24>
```

Whereas we can see the type of the function (it has type `string ->
int`), we get no information about the function itself; that is, we
cannot see its implementation.

## Booleans and Conditional Expressions

The type `bool` represents the set of boolean values containing
precisely the values `true` and `false`. Boolean values are, for instance,
resulting from comparing values for equality and inequality:

```
> 2 < 3;;
val it : bool = true

> "hi" = "hello";;
val it : bool = false
```

Operations on booleans include boolean _conjunction_ (`&&`) and
boolean _disjunction_ (`||`), which implements boolean "and" and
boolean "or", respectively. It is also possible to negate boolean
values, using the function `not`:

    val (&&) : bool -> bool -> bool
    val (||) : bool -> bool -> bool
    val not  : bool -> bool

Here is an example of a boolean expression:

```
> 2 < 3 && 5 >= 5;;
val it : bool = true
```

Notice that because the comparison operators (here `<` and `>=`)
bind strong than `&&`, parentheses are not needed in this example.

Booleans may also be used for controling program evaluation paths
through the use of _conditional_ expressions, also called if-then-else
expressions:

```
let age = 17;;
val age : int = 17

> if age >= 18 then "you may drive a car" else "driving is not ok";;
val it : string = "driving is not ok"
```

## Functions

We have already seen the use of some built-in functions, including
functions for arithmetics (sine, addition, multiplication), for
comparison testing, and for performing string operations.

In F#, it is straightforward to define your own functions built on top
of previously defined functions or built in functions. In fact, the "F"
in F# is really stands for the term functional.

Defining a function can be done by simply extending a
`let`-expression to be _parametric_ in an argument:

```fsharp
> let legal age =
    if age >= 18 then "you may drive a car"
    else "driving is not ok";;
val legal : age:int -> string
```

In this example, we define a function `legal`, which takes an
integer as argument and produces a string as a result. This example is
also the first example demonstrating that code may span several lines
of text; once the first line is entered, `fsharpi` awaits further
input and only when the `;;` end-sequence appear will `fsharpi`
attempt to make sense of the input. Once the function is defined, we
can apply the function to different arguments and observe that the
function behaves differently on different input:

```
> legal 14;;
val it : string = "driving is not ok"

> legal 28;;
val it : string = "you may drive a car"
```

Functions may take multiple parameters as input as exemplified in the
following code that declares a function for determining the volume of
a cylinder, given that the variable `pi` is bound already:

```
> let volume r h = h*pi*r*r;;
val volume : r:float -> h:float -> float
```

It is straightforward to call the function `volume` as can be seen
in the following code:

```
> let vol1 = volume 1.0 10.0;;
val vol1 : float = 31.4
```

**Exercise 3:** _Write a function `bmi` of type `float -> float ->
float` that takes as input the weight and the height of a person and
returns the body mass index for the person. You will probably need to
apply a so-called type constraint to one of the function parameters
in order not to have F# infer that the type of the function is `int
-> int -> int`. The way to do this is to put parentheses around one
of the arguments and specify that it should be of type `float` (as
in `(w:float)`). When applying the `bmi` function to a weight of
83kg and a height of 2.05m, you should obtain a body mass index of
approximately 19.75, which is considered slightly below normal._

**Exercise 4:** _Using your newly defined function, create a new
function `bmi_msg` that, as the `bmi` function takes a weight and
a height as arguments, but now tests (using two conditional
expressions) whether the person has a body mass index below or above
normal. The result of the function should be a string telling the user
if the body mass index is above normal, below normal, or within normal
(a body mass index in the range 20-25 is considered normal). Test your
function on various inputs._

## Pairs and Tuples

It is often advantageous to think of a type as a set of values. In
this way we can think of the type `int` as the set of all integers
and the type `bool` as the set {`true`,`false`} containing the
two possible boolean values. Understanding types as sets opens up the
possibility for extending the universe of types. In this section, we
shall consider product types. As an example, the product type of
`int` and `float`, written `int*float`, is the type representing
the set of pairs where the first component is an integer and the
second component is a floating point value. In F#, pair values are simply
constructed using a `,`:

```
> let p = 34, 2.7;;
val p : int * float = (34, 2.7)
```

To access the components of a pair, we can use the functions `fst`
and `snd`:

   val fst : 'a * 'b -> 'a
   val snd : 'a * 'b -> 'b

Here we see the first instance of so-called _generic types_, which are
used in the types of the functions `fst` and `snd` to indicate
that the functions can be applied to pairs of any type.

An important feature here is that the product type is just as good as
any other type meaning that functions can be declared to take pairs as
arguments and return pairs as results just as well as they can accept
integers and return strings. As an example, here is a function that,
given a readius value, returns a pair containing the circumvent and
the area of a cirkle:

```
> let lenarea r = (2.0*pi*r, pi*r*r);;
val lenarea : r:float -> float * float
```

Now that the function is declared, we can apply it to a particular
radius and extract the area value:

```
> let area = snd(lenarea 5.0);;
val area : float = 78.5
```

## Recursive Functions

Let us consider how we could write a function that adds up the numbers
between 1 and 100. Clearly, we do not write up an expression
`1+2+3+...+100`. Even if this approach would work for summing up the
values between 1 and 100, what if someone asked us to add up the
numbers between 1 and 1000? Instead, we somehow need a way to repeat
computations.

There are different kinds of programming languages that emphasize
different programming paradigms. One paradigm is the _imperative
programming_ paradigm, which emphasizes the use of destructive
updates, which, together with looping constructs, opens a possibility
for arbitrary computing, which, for instance could be to sum up a
range of numbers. Here we will follow another paradigm, which is the
_functional programming_ paradigm, a paradigm that celebrates
immutability whenever possible and which features a number of
reasoning principles that allow programmers to better specify and
reason about properties of the program. An essential part of
functional programming has to do with recursive functions, which are
simply functions that call themselves.

Now consider again the task of writing a function that sums the
integers between 0 and 100. Here is a recursive F# function that does
the job for any integer argument `n`:

```fsharp
> let rec sum n =
    if n <= 0 then 0
    else n + sum (n-1);;
val sum : n:int -> int
```

Notice the special keyword `rec` appearing after the `let`
keyword. The `rec` keyword specifies that it is ok for the function
to call itself inside the function's own body. Now, let us look at
the function in more detail. If the function is called with an
argument of `0`, clearly, the function will return `0` as
a result, which we can easily check:

```
> let sum0 = sum 0;;
val sum0 : int = 0
```

However, if the function is called with the argument `1`, the
immediate result is that the `else`-branch is taken. What this
branch will do is to call `sum` recursively on `n-1` and because
`n` is `1`, we have that `sum` is called with an argument of
`0`. After this call returns, `1` is added to the result of the
call and the resulting value, which is `1`, is returned.

**Exercise 5:** _Write a recursive function called `fac` that
takes an integer `n` as argument and computes the value
`1*2*...*n`. Test your function on a number of input values._

## Working with Programs

## Imperative Programming with Mutable Variables and Arrays

## Functional Programming with Lists